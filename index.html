<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skyblue Realtime Messenger with Calls</title>
  <style>
    /* (Same style as before) */
    * { box-sizing: border-box; }
    body, html {
      margin: 0; padding: 0; height: 100%;
      font-family: Arial, sans-serif;
      background: #ece5dd;
    }
    #app {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      padding: 16px;
    }
    .container {
      background: #fff;
      width: 100%;
      max-width: 440px;
      height: 100%;
      display: flex;
      flex-direction: column;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0,0,0,0.12);
      overflow: hidden;
    }
    .header {
      background: #4ca3dd;
      color: white;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 16px;
      user-select: none;
      gap: 8px;
    }
    .btn-group {
      display: flex;
      gap: 8px;
    }
    button.logout, button.settings, button.call-video, button.call-audio {
      border: 1.5px solid white;
      background: transparent;
      padding: 6px 10px;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: background-color 0.25s;
      user-select: none;
    }
    button.logout:hover, button.settings:hover,
    button.call-video:hover, button.call-audio:hover {
      background: rgba(255 255 255 / 0.2);
    }
    .messages {
      flex: 1;
      padding: 16px 12px;
      overflow-y: auto;
      background: #e5ddd5;
      display: flex;
      flex-direction: column;
      gap: 10px;
      scrollbar-width: thin;
      scrollbar-color: #aaa transparent;
    }
    .messages::-webkit-scrollbar {
      width: 8px;
    }
    .messages::-webkit-scrollbar-thumb {
      background-color: #aaa;
      border-radius: 4px;
    }
    .message {
      max-width: 75%;
      padding: 12px 14px;
      border-radius: 12px;
      background: #a9d5ff;
      align-self: flex-end;
      position: relative;
      word-wrap: break-word;
      font-size: 14px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      user-select: text;
      line-height: 1.3;
      color: #003366;
    }
    .message.other {
      background: white;
      align-self: flex-start;
      color: #202c33;
    }
    .message strong {
      display: block;
      margin-bottom: 6px;
      font-weight: 700;
      font-size: 13px;
      color: #202c33;
    }
    .message img,
    .message video,
    .message audio {
      max-width: 100%;
      border-radius: 10px;
      margin-top: 4px;
      outline: none;
    }
    .timestamp {
      font-size: 10px;
      color: #555;
      margin-top: 6px;
      text-align: right;
      user-select: none;
    }
    .delete-btn {
      position: absolute;
      top: 6px;
      right: 8px;
      color: #d93025;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      line-height: 1;
      user-select: none;
    }
    .input-area {
      display: flex;
      border-top: 1px solid #ccc;
      padding: 12px 14px;
      background: #fff;
      gap: 8px;
    }
    .input-area input[type="text"] {
      flex: 1;
      padding: 12px 16px;
      border-radius: 25px;
      border: 1px solid #ccc;
      outline: none;
      font-size: 14px;
      transition: border-color 0.3s;
    }
    .input-area input[type="text"]:focus {
      border-color: #4ca3dd;
    }
    .input-area button.send {
      background: #4ca3dd;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 18px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: background-color 0.3s;
    }
    .input-area button.send:hover {
      background: #357abd;
    }
    .input-area button.attach {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 20px;
      user-select: none;
      color: #4ca3dd;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .input-area input[type="file"] {
      display: none;
    }

    /* Login */
    .login-box {
      background: white;
      padding: 32px 32px 40px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.12);
      width: 100%;
      max-width: 400px;
      text-align: center;
    }
    .login-box h2 {
      margin-bottom: 24px;
      font-weight: 700;
      color: #4ca3dd;
      user-select: none;
    }
    .login-box input {
      display: block;
      width: 100%;
      margin-bottom: 18px;
      padding: 14px 16px;
      font-size: 15px;
      border-radius: 8px;
      border: 1px solid #ccc;
      outline: none;
      transition: border-color 0.3s;
    }
    .login-box input:focus {
      border-color: #4ca3dd;
    }
    .login-box button {
      width: 100%;
      padding: 14px 0;
      background: #4ca3dd;
      border: none;
      color: white;
      border-radius: 10px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s;
    }
    .login-box button:hover {
      background: #357abd;
    }

    /* Call modal */
    #callModal {
      position: fixed;
      top:0; left:0; right:0; bottom:0;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #callModal.active {
      display: flex;
    }
    #callBox {
      background: white;
      border-radius: 12px;
      padding: 20px;
      max-width: 420px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #callBox video {
      width: 100%;
      border-radius: 10px;
      background: black;
    }
    #callBox audio {
      display: none;
    }
    #callControls {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    #callControls button {
      background: #4ca3dd;
      border: none;
      color: white;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s;
    }
    #callControls button:hover {
      background: #357abd;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- Call modal -->
  <div id="callModal">
    <div id="callBox">
      <video id="localVideo" autoplay muted playsinline></video>
      <video id="remoteVideo" autoplay playsinline></video>
      <audio id="remoteAudio" autoplay></audio>
      <div id="callControls">
        <button id="hangupBtn">Hang Up</button>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-storage-compat.js"></script>

  <script>
    const appDiv = document.getElementById('app');
    const callModal = document.getElementById('callModal');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const remoteAudio = document.getElementById('remoteAudio');
    const hangupBtn = document.getElementById('hangupBtn');

    const firebaseConfig = {
      apiKey: "AIzaSyCy9CKJ6CELheBhw7Gs0BgsE1E0FsoYdgU",
      authDomain: "project-955237504610034331.firebaseapp.com",
      databaseURL: "https://project-955237504610034331-default-rtdb.firebaseio.com",
      projectId: "project-955237504610034331",
      storageBucket: "project-955237504610034331.appspot.com",
      messagingSenderId: "955237504610034331",
      appId: "1:955237504610034331:web:cd6d832647fc98c516f0d9"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();
    const storage = firebase.storage();

    let currentUser = null;
    let currentDisplayName = "";

    let peerConnection = null;
    const servers = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
      ]
    };

    let callRef = null; // For signaling

    function renderLogin() {
      appDiv.innerHTML = `
      <div class="login-box">
        <h2>Login / Signup</h2>
        <input type="email" id="email" placeholder="Email" autocomplete="username" />
        <input type="password" id="password" placeholder="Password" autocomplete="current-password" />
        <button id="loginBtn">Login</button>
      </div>
      `;
      document.getElementById('loginBtn').onclick = login;
    }

    async function renderChat(user) {
      currentUser = user;
      currentDisplayName = await loadDisplayName();

      appDiv.innerHTML = `
        <div class="container">
          <div class="header">
            <div>
              <span>${currentDisplayName || user.email || 'User'}</span>
            </div>
            <div class="btn-group">
              <button class="call-video" title="Start Video Call">📹</button>
              <button class="call-audio" title="Start Voice Call">🎤</button>
              <button class="settings" title="Change Display Name">⚙</button>
              <button class="logout" title="Logout">Logout</button>
            </div>
          </div>
          <div id="messages" class="messages"></div>
          <div class="input-area">
            <input type="text" id="msgInput" placeholder="Type a message" autocomplete="off" />
            <label class="attach" title="Attach media">
              📎
              <input type="file" id="mediaInput" accept="image/*,video/*,audio/*" />
            </label>
            <button class="send" title="Send Message">➡️</button>
          </div>
        </div>
      `;

      document.querySelector('.logout').onclick = logout;
      document.querySelector('.settings').onclick = changeDisplayName;
      document.querySelector('.send').onclick = sendMessage;
      document.getElementById('mediaInput').addEventListener('change', sendMedia);

      document.querySelector('.call-video').onclick = () => startCall(true);
      document.querySelector('.call-audio').onclick = () => startCall(false);

      loadMessages(user);
    }

    // Display name loading and changing
    async function loadDisplayName() {
      const snap = await db.ref(`displayNames/${currentUser.uid}`).once('value');
      return snap.val() || "";
    }

    async function changeDisplayName() {
      const newName = prompt("Enter your new display name:", currentDisplayName);
      if (newName !== null) {
        await db.ref(`displayNames/${currentUser.uid}`).set(newName);
        currentDisplayName = newName;
        // Update header
        document.querySelector('.header > div > span').textContent = newName || currentUser.email || "User";
      }
    }

    // Messages display
    function displayMessage(id, msg) {
      const messagesDiv = document.getElementById("messages");
      if (!messagesDiv) return;

      // Ignore if message deleted
      if (!msg) return;

      // Check if message div exists, update or create
      let div = document.getElementById("msg-" + id);
      if (!div) {
        div = document.createElement("div");
        div.id = "msg-" + id;
        div.classList.add("message");
        messagesDiv.appendChild(div);
      }

      div.classList.toggle("other", msg.sender !== currentUser.uid);
      div.innerHTML = "";

      const senderName = msg.sender === currentUser.uid ? currentDisplayName || currentUser.email : "";
      // Get display name for other sender, cache it for performance
      if (msg.sender !== currentUser.uid) {
        // Async get display name (non-blocking)
        db.ref(`displayNames/${msg.sender}`).once('value').then(snap => {
          const name = snap.val() || "User";
          const strong = div.querySelector("strong");
          if (strong) strong.textContent = name;
        });
      }

      if (senderName) {
        const strong = document.createElement("strong");
        strong.textContent = senderName;
        div.appendChild(strong);
      } else if (msg.sender !== currentUser.uid) {
        const strong = document.createElement("strong");
        strong.textContent = "Loading...";
        div.appendChild(strong);
      }

      if (msg.text) {
        const p = document.createElement("p");
        p.textContent = msg.text;
        div.appendChild(p);
      }

      if (msg.mediaURL && msg.mediaType) {
        let mediaElem = null;
        if (msg.mediaType.startsWith('image/')) {
          mediaElem = document.createElement('img');
          mediaElem.src = msg.mediaURL;
          mediaElem.style.maxWidth = "200px";
          mediaElem.loading = "lazy";
        } else if (msg.mediaType.startsWith('video/')) {
          mediaElem = document.createElement('video');
          mediaElem.src = msg.mediaURL;
          mediaElem.controls = true;
          mediaElem.preload = "metadata";
          mediaElem.style.maxHeight = "200px";
        } else if (msg.mediaType.startsWith('audio/')) {
          mediaElem = document.createElement('audio');
          mediaElem.src = msg.mediaURL;
          mediaElem.controls = true;
          mediaElem.preload = "metadata";
          mediaElem.style.maxHeight = "40px";
        }
        if (mediaElem) div.appendChild(mediaElem);
      }

      const timeDiv = document.createElement("div");
      timeDiv.classList.add("timestamp");
      timeDiv.textContent = new Date(msg.timestamp).toLocaleString();
      div.appendChild(timeDiv);

      // Delete button only for own messages
      if (msg.sender === currentUser.uid) {
        const delBtn = document.createElement('button');
        delBtn.classList.add('delete-btn');
        delBtn.title = "Delete message";
        delBtn.textContent = "✕";
        delBtn.onclick = () => deleteMessage(id, msg);
        div.appendChild(delBtn);
      }

      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function loadMessages(user) {
      const messagesRef = db.ref('messages');

      messagesRef.off(); // Remove previous listeners

      messagesRef.on('child_added', snapshot => {
        const msg = snapshot.val();
        displayMessage(snapshot.key, msg);
      });

      messagesRef.on('child_removed', snapshot => {
        const msgDiv = document.getElementById('msg-' + snapshot.key);
        if (msgDiv) msgDiv.remove();
      });
    }

    async function sendMessage() {
      const input = document.getElementById("msgInput");
      const text = input.value.trim();
      if (!text) return;
      if (!currentUser) return alert("Not logged in!");

      const messagesRef = db.ref('messages');
      const newMsgRef = messagesRef.push();

      const messageData = {
        text,
        sender: currentUser.uid,
        timestamp: Date.now()
      };

      await newMsgRef.set(messageData);
      input.value = "";
    }

    async function sendMedia() {
      const fileInput = document.getElementById('mediaInput');
      if (fileInput.files.length === 0) return;
      if (!currentUser) return alert("Not logged in!");

      const file = fileInput.files[0];
      fileInput.value = "";

      const messagesRef = db.ref('messages');
      const newMsgRef = messagesRef.push();

      try {
        const storageRef = storage.ref(`media/${currentUser.uid}/${newMsgRef.key}_${file.name}`);
        const snapshot = await storageRef.put(file);
        const downloadURL = await snapshot.ref.getDownloadURL();

        const messageData = {
          mediaURL: downloadURL,
          mediaType: file.type,
          sender: currentUser.uid,
          timestamp: Date.now()
        };
        await newMsgRef.set(messageData);
      } catch (error) {
        alert("Failed to upload media: " + error.message);
      }
    }

    async function deleteMessage(id, msg) {
      if (!confirm("Delete this message?")) return;

      try {
        await db.ref(`messages/${id}`).remove();

        if (msg.mediaURL) {
          const fileRef = storage.refFromURL(msg.mediaURL);
          await fileRef.delete();
        }
      } catch (e) {
        console.warn("Error deleting message/media:", e);
      }
    }

    // Auth functions
    async function logout() {
      await auth.signOut();
    }

    async function login() {
      const emailInput = document.getElementById("email");
      const passwordInput = document.getElementById("password");
      const email = emailInput.value.trim();
      const password = passwordInput.value;

      if (!email || !password) {
        alert("Please enter email and password");
        return;
      }

      try {
        await auth.signInWithEmailAndPassword(email, password);
      } catch (e) {
        if (e.code === "auth/user-not-found") {
          if (confirm("User not found. Create account?")) {
            try {
              await auth.createUserWithEmailAndPassword(email, password);
            } catch (e2) {
              alert("Failed to create user: " + e2.message);
            }
          }
        } else {
          alert("Login failed: " + e.message);
        }
      }
    }

    // WebRTC Call functionality

    async function startCall(isVideo) {
      if (!currentUser) return alert("Not logged in!");
      if (peerConnection) {
        alert("Call already in progress");
        return;
      }

      // Prompt user for the uid of the other party (in a real app you'd have contacts or chat partner)
      const otherUid = prompt("Enter the UID of the user you want to call:");
      if (!otherUid) return;

      callRef = db.ref(`calls/${currentUser.uid}_${otherUid}`);
      const otherCallRef = db.ref(`calls/${otherUid}_${currentUser.uid}`);

      peerConnection = new RTCPeerConnection(servers);

      // Setup media
      let constraints = { audio: true };
      if (isVideo) constraints.video = true;

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
        localVideo.srcObject = stream;
      } catch (e) {
        alert("Failed to get local media: " + e.message);
        cleanupCall();
        return;
      }

      // Show modal
      callModal.classList.add('active');
      remoteVideo.style.display = isVideo ? 'block' : 'none';
      remoteAudio.style.display = isVideo ? 'none' : 'block';

      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          callRef.child('candidates').push(event.candidate.toJSON());
        }
      };

      peerConnection.ontrack = event => {
        const remoteStream = event.streams[0];
        if (isVideo) {
          remoteVideo.srcObject = remoteStream;
        } else {
          remoteAudio.srcObject = remoteStream;
        }
      };

      // Listen for answer & candidates from other user
      otherCallRef.on('value', async snapshot => {
        const data = snapshot.val();
        if (!data) return;
        if (data.answer && peerConnection.signalingState !== "stable") {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
        if (data.candidates) {
          Object.values(data.candidates).forEach(async candidate => {
            try {
              await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            } catch(e) {
              console.warn("Error adding ICE candidate", e);
            }
          });
        }
      });

      // Create offer and set local description
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      await callRef.set({
        offer: offer.toJSON(),
        caller: currentUser.uid,
        callee: otherUid,
        candidates: null,
        answer: null
      });

      hangupBtn.onclick = hangupCall;

      // Listen for hangup
      otherCallRef.child('hangup').on('value', snap => {
        if (snap.exists()) {
          alert("Call ended by remote user.");
          cleanupCall();
        }
      });
    }

    // Incoming call listener
    function listenForIncomingCalls() {
      if (!currentUser) return;
      const incomingCallsRef = db.ref('calls');
      incomingCallsRef.on('child_added', async snapshot => {
        const callId = snapshot.key;
        const data = snapshot.val();

        if (!data) return;
        if (data.callee === currentUser.uid && !peerConnection) {
          const accept = confirm(`Incoming call from ${data.caller}. Accept?`);
          if (!accept) {
            db.ref(`calls/${callId}/hangup`).set(true);
            return;
          }
          await answerCall(callId, data);
        }
      });
    }

    async function answerCall(callId, callData) {
      peerConnection = new RTCPeerConnection(servers);

      let constraints = { audio: true };
      if (callData.offer.sdp.includes('m=video')) {
        constraints.video = true;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
        localVideo.srcObject = stream;
      } catch (e) {
        alert("Failed to get local media: " + e.message);
        cleanupCall();
        return;
      }

      const callRef = db.ref(`calls/${callId}`);

      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          callRef.child('candidates').push(event.candidate.toJSON());
        }
      };

      peerConnection.ontrack = event => {
        const remoteStream = event.streams[0];
        if (constraints.video) {
          remoteVideo.srcObject = remoteStream;
        } else {
          remoteAudio.srcObject = remoteStream;
        }
      };

      await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      await callRef.update({ answer: answer.toJSON() });

      callModal.classList.add('active');
      remoteVideo.style.display = constraints.video ? 'block' : 'none';
      remoteAudio.style.display = constraints.video ? 'none' : 'block';

      hangupBtn.onclick = () => {
        db.ref(`calls/${callId}/hangup`).set(true);
        cleanupCall();
      };

      // Listen for hangup
      callRef.child('hangup').on('value', snap => {
        if (snap.exists()) {
          alert("Call ended by remote user.");
          cleanupCall();
        }
      });
    }

    function cleanupCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      callModal.classList.remove('active');
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      remoteAudio.srcObject = null;
      callRef = null;
    }

    // On auth state change
    auth.onAuthStateChanged(user => {
      if (user) {
        renderChat(user);
        listenForIncomingCalls();
      } else {
        renderLogin();
      }
    });

    // Initial render
    renderLogin();

  </script>

</body>
</html>
